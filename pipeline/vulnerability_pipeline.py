#!/usr/bin/env python3
# -*- coding: utf-8 -*-

import json
import os
import re
import csv
import yaml
import requests
from typing import Dict, List, Any, Optional, Union
from pathlib import Path
import logging
from dataclasses import dataclass
from enum import Enum

# 配置日志
logging.basicConfig(level=logging.INFO, format='%(asctime)s - %(levelname)s - %(message)s')
logger = logging.getLogger(__name__)

@dataclass
class VulnerabilityResult:
    """漏洞检索结果"""
    rag_summary: str
    name: str
    path: str
    image: str
    contracts: Dict[str, Any]

class VulnerabilityRetriever:
    """漏洞检索系统"""
    
    def __init__(self):
        # 配置路径
        self.config_file = "config.json"
        self.knowledge_base_path = "cve_list.csv"
        self.vulhub_base_path = "c:\\Users\\86199\\Desktop\\EpicCyberRange\\vulhub"
        self.output_path = "output"
        self.template_path = "c:\\Users\\86199\\Desktop\\EpicCyberRange\\docs\\数据\\模板.md"
        
        # 确保输出目录存在
        os.makedirs(self.output_path, exist_ok=True)
        
        # 加载配置文件
        self.config = self._load_config()
        
        # 读取模板
        self.template = self._load_template()
        
        # 配置LLM
        self.llm_config = {
            "api_url": self.config.get("pipeline_config", {}).get("llm_api_url", ""),
            "api_key": self.config.get("pipeline_config", {}).get("llm_api_key", ""),
            "model": self.config.get("llm_config", {}).get("model", "gpt-3.5-turbo"),
            "temperature": self.config.get("llm_config", {}).get("temperature", 0.7),
            "max_tokens": self.config.get("llm_config", {}).get("max_tokens", 1000),
            "prompt_template": self.config.get("llm_config", {}).get("prompt_template", ""),
        }
        
        # 加载知识库
        self.knowledge_base = self._load_knowledge_base()
        
        # 加载漏洞类型列表
        self.vuln_types = self.config.get("vuln_types", [])
        logger.info(f"加载了 {len(self.vuln_types)} 种漏洞类型")
        
    def _load_config(self) -> Dict[str, Any]:
        """加载配置文件"""
        try:
            if os.path.exists(self.config_file):
                with open(self.config_file, 'r', encoding='utf-8') as f:
                    config = json.load(f)
                logger.info(f"配置文件加载成功: {self.config_file}")
                return config
            else:
                logger.warning(f"配置文件不存在: {self.config_file}")
                return {}
        except Exception as e:
            logger.error(f"加载配置文件失败: {e}")
            return {}
    
    def _load_template(self) -> str:
        """加载rag_summary模板"""
        try:
            if os.path.exists(self.template_path):
                with open(self.template_path, 'r', encoding='utf-8') as f:
                    content = f.read()
                    # 提取模板部分
                    if "模板" in content:
                        template_start = content.find("模板")
                        template_section = content[template_start:]
                        return template_section
            return "漏洞概要生成模板未找到"
        except Exception as e:
            logger.warning(f"读取模板失败: {e}")
            return "漏洞概要生成模板未找到"
    
    def _load_knowledge_base(self) -> Dict[str, str]:
        """加载知识库"""
        knowledge_base = {}
        try:
            if os.path.exists(self.knowledge_base_path):
                with open(self.knowledge_base_path, 'r', encoding='utf-8-sig') as f:
                    reader = csv.DictReader(f)
                    for row in reader:
                        name = row.get('name', '').strip()
                        path = row.get('path', '').strip()
                        if name and path:
                            knowledge_base[name] = path
                logger.info(f"知识库加载成功: {len(knowledge_base)} 条记录")
            else:
                logger.warning(f"知识库文件不存在: {self.knowledge_base_path}")
        except Exception as e:
            logger.error(f"加载知识库失败: {e}")
        return knowledge_base

    def extract_cve_numbers(self, text: str) -> List[str]:
        """从文本中提取CVE编号，过滤非数字字符、空值，完成去重处理"""
        # 移除文本中的特殊字符，只保留字母、数字、连字符和空格
        cleaned_text = re.sub(r'[^a-zA-Z0-9-\s]', '', text)
        # 使用更严格的CVE编号正则表达式
        cve_pattern = r'CVE-\d{4}-\d+'
        cve_numbers = re.findall(cve_pattern, cleaned_text, re.IGNORECASE)
        # 格式化并去重
        formatted_cves = []
        for cve in cve_numbers:
            # 确保CVE编号格式正确（大写）
            formatted_cve = cve.upper()
            if formatted_cve not in formatted_cves:
                formatted_cves.append(formatted_cve)
        return formatted_cves
    
    def read_docker_compose(self, vuln_path: str) -> Dict[str, Any]:
        """读取docker-compose.yml文件"""
        docker_file = os.path.join(self.vulhub_base_path, vuln_path, "docker-compose.yml")
        result = {"image": "", "ingress": []}
        
        try:
            if os.path.exists(docker_file):
                with open(docker_file, 'r', encoding='utf-8') as f:
                    compose_data = yaml.safe_load(f)
                    
                # 提取image和ports
                if 'services' in compose_data:
                    for service_name, service_config in compose_data['services'].items():
                        if 'image' in service_config:
                            result["image"] = service_config['image']
                        if 'ports' in service_config:
                            ports = service_config['ports']
                            if isinstance(ports, list):
                                result["ingress"] = []
                                for port in ports:
                                    if isinstance(port, str) and ':' in port:
                                        # 处理 "8080:8080" 格式
                                        host_port = port.split(':')[0]
                                        try:
                                            result["ingress"].append(int(host_port))
                                        except:
                                            pass
                                    elif isinstance(port, int):
                                        result["ingress"].append(port)
        except Exception as e:
            logger.warning(f"读取docker-compose.yml失败 {docker_file}: {e}")
        
        return result
    
    def read_readme_file(self, vuln_path: str) -> str:
        """读取README.zh-cn.md文件"""
        readme_file = os.path.join(self.vulhub_base_path, vuln_path, "README.zh-cn.md")
        logger.info(f"尝试读取README文件: {readme_file}")
        
        if not os.path.exists(readme_file):
            logger.warning(f"README.zh-cn.md文件不存在，尝试其他替代文件")
            # 尝试其他可能的README文件
            alternatives = [
                os.path.join(self.vulhub_base_path, vuln_path, "README.md"),
                os.path.join(self.vulhub_base_path, vuln_path, "README"),
            ]
            for alt_file in alternatives:
                if os.path.exists(alt_file):
                    readme_file = alt_file
                    logger.info(f"使用替代README文件: {readme_file}")
                    break
        
        try:
            if os.path.exists(readme_file):
                with open(readme_file, 'r', encoding='utf-8') as f:
                    content = f.read()
                    logger.info(f"成功读取README文件，内容长度: {len(content)} 字符")
                    return content
            else:
                logger.warning(f"所有README文件都不存在: {readme_file}")
                return ""
        except Exception as e:
            logger.error(f"读取README文件失败: {e}")
            return ""
    
    def search_in_knowledge_base(self, cve_number: str) -> Optional[str]:
        """在知识库中搜索CVE编号"""
        return self.knowledge_base.get(cve_number)
    
    def call_llm_api(self, cve_number: str, context: str = "") -> Dict[str, str]:
        """调用大模型API生成vuln_type和rag_summary"""
        # 检查LLM API配置
        if not self.llm_config["api_url"] or "api_keys" in self.llm_config["api_url"]:
            logger.warning("LLM API URL配置错误，使用默认值")
            return {
                "vuln_type": "unknown",
                "rag_summary": f"未匹配到有效漏洞名称: {cve_number}"
            }
        
        try:
            # 构建提示词
            prompt_template = self.llm_config.get("prompt_template", "")
            
            if prompt_template:
                # 使用配置文件中的提示模板，只替换{name}和{context}占位符
                prompt = prompt_template.format(name=cve_number, context=context)
            else:
                # 使用默认提示模板
                prompt = f"""
请为漏洞 {cve_number} 生成以下信息：

{self.template}

漏洞详细信息：{context}

请严格按照模板格式生成中文rag_summary，内容要准确、专业、详细。
同时生成漏洞类型（vuln_type），如：rce, sqli, xss, ssrf等。

输出格式：
vuln_type: <漏洞类型>
rag_summary: <按照模板生成的中文描述>
"""
            
            logger.info(f"使用LLM提示词: {prompt[:200]}...")
            
            # 调用实际的LLM API
            response = requests.post(
                self.llm_config["api_url"],
                headers={
                    'Authorization': f'Bearer {self.llm_config["api_key"]}',
                    'Content-Type': 'application/json'
                },
                json={
                    "model": self.llm_config["model"],
                    "messages": [
                        {"role": "system", "content": "你是一位专业的网络安全分析师，擅长分析漏洞并生成详细的漏洞摘要。"},
                        {"role": "user", "content": prompt}
                    ],
                    "temperature": self.llm_config["temperature"],
                    "max_tokens": self.llm_config["max_tokens"]
                }
            )
            
            # 解析响应
            response.raise_for_status()  # 检查HTTP状态码
            response_data = response.json()
            logger.info(f"LLM API调用成功，响应状态: {response.status_code}")
            logger.info(f"LLM API响应: {json.dumps(response_data, ensure_ascii=False)[:500]}...")
            
            # 根据DeepSeek API的响应格式解析输出
            if "choices" in response_data and response_data["choices"]:
                llm_output = response_data["choices"][0].get("message", {}).get("content", "").strip()
                logger.info(f"LLM输出: {llm_output[:500]}...")
                
                # 解析LLM输出，提取vuln_type和rag_summary
                vuln_type = "unknown"
                rag_summary = f"未匹配到有效漏洞名称: {cve_number}"
                
                # 尝试提取vuln_type
                vuln_type_match = re.search(r'vuln_type:\s*([\w_-]+)', llm_output, re.IGNORECASE)
                if vuln_type_match:
                    extracted_vuln_type = vuln_type_match.group(1).lower()
                    # 验证漏洞类型是否在配置列表中，不在则使用unknown
                    vuln_type = extracted_vuln_type if extracted_vuln_type in self.vuln_types else "unknown"
                    logger.info(f"提取到漏洞类型: {vuln_type}")
                
                # 尝试提取rag_summary
                rag_summary_match = re.search(r'rag_summary:\s*(.+)', llm_output, re.DOTALL)
                if rag_summary_match:
                    rag_summary = rag_summary_match.group(1).strip()
                    logger.info(f"提取到漏洞摘要，长度: {len(rag_summary)} 字符")
                else:
                    # 如果没有找到rag_summary: 开头，检查输出是否符合模板格式
                    if "漏洞" in llm_output and "端口" in llm_output:
                        # 直接使用整个输出作为rag_summary
                        rag_summary = llm_output.strip()
                        logger.info(f"直接使用LLM输出作为漏洞摘要，长度: {len(rag_summary)} 字符")
                    else:
                        # 如果输出不符合预期格式，生成更详细的错误信息
                        logger.warning(f"LLM输出格式不符合预期: {llm_output[:200]}...")
                
                return {
                    "vuln_type": vuln_type,
                    "rag_summary": rag_summary
                }
            else:
                logger.error(f"LLM API响应格式错误，缺少choices字段: {json.dumps(response_data, ensure_ascii=False)}")
                return {
                    "vuln_type": "unknown",
                    "rag_summary": f"未匹配到有效漏洞名称: {cve_number}"
                }
            
        except Exception as e:
            logger.error(f"LLM API调用失败: {e}")
            import traceback
            traceback.print_exc()
            return {
                "vuln_type": "unknown", 
                "rag_summary": f"未匹配到有效漏洞名称: {cve_number}"
            }
    
    def process_cve(self, cve_number: str) -> VulnerabilityResult:
        """处理单个CVE编号，实现两种场景的处理逻辑"""
        logger.info(f"处理CVE编号: {cve_number}")
        
        # 初始化默认值
        name = cve_number
        path = None
        image = None
        ingress = []
        vuln_type = None
        rag_summary = None
        
        # 在知识库中搜索
        vuln_path = self.search_in_knowledge_base(cve_number)
        
        if vuln_path:
            # 场景1：知识库检索匹配成功
            logger.info(f"场景1：在知识库中找到 {cve_number}: {vuln_path}")
            
            # 1. 提取核心关联字段
            name = cve_number
            path = vuln_path
            
            # 2. 路径关联vulhub仓库，定位对应漏洞文件夹
            vuln_folder = os.path.join(self.vulhub_base_path, vuln_path)
            
            # 3. 读取解析 docker-compose.yml 文件
            docker_info = self.read_docker_compose(vuln_path)
            image = docker_info["image"] if docker_info["image"] else None
            ingress = docker_info["ingress"] if isinstance(docker_info["ingress"], list) else []
            
            # 4. 读取 README.zh-cn.md 文件
            readme_content = self.read_readme_file(vuln_path)
            
            # 5. 调用大模型生成标准化字段
            context = f"漏洞路径: {vuln_path}, Docker镜像: {image}, 端口: {ingress}, README内容: {readme_content[:1000]}"
            llm_result = self.call_llm_api(cve_number, context)
            vuln_type = llm_result["vuln_type"]
            rag_summary = llm_result["rag_summary"]
            
        else:
            # 场景2：知识库检索匹配失败
            logger.info(f"场景2：在知识库中未找到 {cve_number}，调用大模型搜索完整漏洞信息")
            
            # 调用大模型以该漏洞编号为核心关键词进行精准检索，要求生成完整信息
            # 构建更详细的提示词，要求大模型生成完整的漏洞信息
            detailed_prompt = f"""
请为漏洞 {cve_number} 生成以下完整信息：

1. 漏洞类型（vuln_type）：从以下列表中选择一个：{', '.join(self.vuln_types)}
2. 漏洞摘要（rag_summary）：按照模板生成详细的中文描述
   - 漏洞标识（CVE 编号）
   - 受影响组件（软件 / 框架及版本）
   - 漏洞类型
   - 利用前置条件
   - 核心利用操作
   - 危害效果
   - 环境信息（镜像 + 端口，如有）
3. 漏洞路径（path）：如果已知，提供漏洞在vulhub中的路径，格式如：component/CVE-xxxx-xxxx
4. Docker镜像（image）：如果已知，提供相关的Docker镜像名称
5. 端口信息（ingress）：如果已知，提供相关的端口号

请严格按照以下格式输出，不要添加任何额外内容：
vuln_type: <漏洞类型>
rag_summary: <按照模板生成的中文描述>
path: <漏洞路径或unknown>
image: <Docker镜像或unknown>
ingress: <端口号或[]>

例如：
vuln_type: rce
rag_summary: 漏洞 CVE-2024-39907 是 1Panel 1.10.10 中的 rce 漏洞。该漏洞需满足 未授权访问条件，攻击者可通过 构造恶意请求，发送至 管理接口触发漏洞；利用成功后可直接导致 远程代码执行，进而可能 获取服务器控制权，对 整个系统 造成严重威胁。对应的环境镜像为 vulhub/1panel:1.10.10，默认运行在 10086 端口。
path: 1panel/CVE-2024-39907
image: vulhub/1panel:1.10.10
ingress: 10086
"""
            
            # 直接调用大模型API获取完整信息
            llm_output = None
            try:
                # 使用自定义提示词调用大模型
                response = requests.post(
                    self.llm_config["api_url"],
                    headers={
                        'Authorization': f'Bearer {self.llm_config["api_key"]}',
                        'Content-Type': 'application/json'
                    },
                    json={
                        "model": self.llm_config["model"],
                        "messages": [
                            {"role": "system", "content": "你是一位专业的网络安全分析师，擅长分析漏洞并生成详细的漏洞信息。"},
                            {"role": "user", "content": detailed_prompt}
                        ],
                        "temperature": self.llm_config["temperature"],
                        "max_tokens": self.llm_config["max_tokens"]
                    }
                )
                response.raise_for_status()
                response_data = response.json()
                
                if "choices" in response_data and response_data["choices"]:
                    llm_output = response_data["choices"][0].get("message", {}).get("content", "").strip()
                    logger.info(f"LLM输出完整漏洞信息: {llm_output[:500]}...")
            except Exception as e:
                logger.error(f"直接调用大模型搜索失败: {e}")
            
            if llm_output:
                # 解析大模型输出，提取所有必要字段
                # 提取vuln_type
                vuln_type_match = re.search(r'vuln_type:\s*([\w_-]+)', llm_output, re.IGNORECASE)
                if vuln_type_match:
                    extracted_vuln_type = vuln_type_match.group(1).lower()
                    vuln_type = extracted_vuln_type if extracted_vuln_type in self.vuln_types else "unknown"
                else:
                    vuln_type = "unknown"
                
                # 提取rag_summary
                rag_summary_match = re.search(r'rag_summary:\s*(.+?)(?=\n\w+:|$)', llm_output, re.DOTALL)
                if rag_summary_match:
                    rag_summary = rag_summary_match.group(1).strip()
                else:
                    rag_summary = f"未匹配到有效漏洞名称: {cve_number}"
                
                # 提取path
                path_match = re.search(r'path:\s*([\w\-\/]+|unknown)', llm_output, re.IGNORECASE)
                if path_match:
                    path = path_match.group(1)
                else:
                    path = "unknown"
                
                # 提取image
                image_match = re.search(r'image:\s*([\w\-\/\.:]+|unknown)', llm_output, re.IGNORECASE)
                if image_match:
                    image = image_match.group(1)
                else:
                    image = "unknown"
                
                # 提取ingress
                ingress_match = re.search(r'ingress:\s*(\d+|\[\])', llm_output, re.IGNORECASE)
                if ingress_match:
                    ingress_value = ingress_match.group(1)
                    if ingress_value == "[]":
                        ingress = []
                    else:
                        try:
                            ingress = [int(ingress_value)]
                        except:
                            ingress = []
                else:
                    ingress = []
                
                logger.info(f"从LLM输出提取到完整信息: vuln_type={vuln_type}, path={path}, image={image}, ingress={ingress}")
            else:
                # 大模型调用失败或没有有效输出
                logger.info(f"未检索到 {cve_number} 的有效漏洞信息")
                vuln_type = "unknown"
                rag_summary = "未匹配到有效漏洞名称"
                path = "unknown"
                image = "unknown"
                ingress = []
        
        # 确保返回的字段符合数据格式要求
        return VulnerabilityResult(
            rag_summary=rag_summary or "未匹配到有效漏洞名称",
            name=name,
            path=path,
            image=image,
            contracts={
                "ingress": ingress,
                "vuln_type": vuln_type
            }
        )
    
    def run(self, input_data: str = None, input_file: str = None) -> List[VulnerabilityResult]:
        """运行主流程，支持文字输入和文件输入"""
        logger.info("开始漏洞检索流程")
        
        results = []
        cve_numbers = []
        
        if input_data:
            # 处理文字输入
            logger.info("处理文字输入")
            cve_numbers = self.extract_cve_numbers(input_data)
            logger.info(f"从文字输入提取到 {len(cve_numbers)} 个CVE编号: {cve_numbers}")
        
        elif input_file:
            # 处理文件输入
            logger.info(f"处理文件输入: {input_file}")
            
            # 1. 校验文件存在性
            if not os.path.exists(input_file):
                logger.error(f"文件不存在: {input_file}")
                return results
            
            # 2. 校验文件类型（只处理文本文件）
            file_ext = os.path.splitext(input_file)[1].lower()
            supported_extensions = ['.txt', '.csv']
            if file_ext not in supported_extensions:
                logger.error(f"不支持的文件类型: {file_ext}，只支持 {supported_extensions}")
                return results
            
            # 3. 尝试读取文件，支持多种编码
            file_content = ""
            encodings = ['utf-8', 'gbk', 'latin-1', 'utf-16']
            encoding_success = False
            
            for encoding in encodings:
                try:
                    with open(input_file, 'r', encoding=encoding) as f:
                        file_content = f.read()
                    encoding_success = True
                    logger.info(f"使用编码 {encoding} 成功读取文件")
                    break
                except UnicodeDecodeError:
                    continue
                except Exception as e:
                    logger.error(f"读取文件失败 {input_file}: {e}")
                    break
            
            if not encoding_success:
                logger.error(f"无法读取文件 {input_file}: 编码兼容性问题")
                return results
            
            # 4. 提取CVE编号
            cve_numbers = self.extract_cve_numbers(file_content)
            logger.info(f"从文件 {input_file} 提取到 {len(cve_numbers)} 个CVE编号: {cve_numbers}")
        
        else:
            logger.error("请提供输入数据或文件")
            return results
        
        # 5. 校验提取到的CVE编号是否有效
        if not cve_numbers:
            logger.warning("未提取到有效的CVE编号")
            return results
        
        # 处理每个CVE编号
        for cve_number in cve_numbers:
            try:
                result = self.process_cve(cve_number)
                
                # 数据格式校验与标准化
                standardized_result = self._standardize_result(result)
                
                # 数据格式校验
                if not self._validate_data_format(standardized_result):
                    logger.error(f"CVE {cve_number} 数据格式校验失败，跳过保存")
                    continue
                
                results.append(standardized_result)
                
            except Exception as e:
                logger.error(f"处理CVE {cve_number} 失败: {e}")
                import traceback
                traceback.print_exc()
                continue
        
        # 根据处理的漏洞数量决定输出方式
        if len(results) == 1:
            # 单个漏洞：只输出单个结果
            cve_number = results[0].name
            output_file = os.path.join(self.output_path, f"{cve_number}.json")
            self._save_result_to_file(results[0], output_file)
            logger.info(f"单个漏洞结果已保存到: {output_file}")
        elif len(results) >= 2:
            # 多个漏洞：只输出批量结果，添加时间戳确保文件名唯一
            import datetime
            timestamp = datetime.datetime.now().strftime("%Y%m%d_%H%M%S")
            batch_output_file = os.path.join(self.output_path, f"批量结果_{len(results)}个漏洞_{timestamp}.json")
            self._save_result_to_file([result.__dict__ for result in results], batch_output_file, is_batch=True)
            logger.info(f"批量结果已保存到: {batch_output_file}")
        
        logger.info(f"漏洞检索流程完成，共处理 {len(results)} 个CVE")
        return results
    
    def _standardize_result(self, result: VulnerabilityResult) -> VulnerabilityResult:
        """标准化结果格式，确保所有字段符合要求"""
        # 确保所有字段符合数据格式要求
        standardized_contracts = {
            "ingress": result.contracts.get("ingress", []) if isinstance(result.contracts.get("ingress"), list) else [],
            "vuln_type": result.contracts.get("vuln_type")
        }
        
        return VulnerabilityResult(
            rag_summary=result.rag_summary or "未匹配到有效漏洞名称",
            name=result.name or "",
            path=result.path,
            image=result.image,
            contracts=standardized_contracts
        )
    
    def _validate_data_format(self, result: VulnerabilityResult) -> bool:
        """验证数据格式是否符合要求"""
        try:
            # 验证字段名和数据类型
            if not isinstance(result.name, str):
                logger.error("name字段必须是字符串")
                return False
            
            if result.path is not None and not isinstance(result.path, str):
                logger.error("path字段必须是字符串或None")
                return False
            
            if result.image is not None and not isinstance(result.image, str):
                logger.error("image字段必须是字符串或None")
                return False
            
            if not isinstance(result.contracts, dict):
                logger.error("contracts字段必须是字典")
                return False
            
            if not isinstance(result.contracts.get("ingress", []), list):
                logger.error("contracts.ingress字段必须是数组")
                return False
            
            vuln_type = result.contracts.get("vuln_type")
            if vuln_type is not None and vuln_type not in self.vuln_types:
                logger.error(f"contracts.vuln_type字段必须是config.json中定义的漏洞类型，当前值: {vuln_type}")
                return False
            
            if not isinstance(result.rag_summary, str):
                logger.error("rag_summary字段必须是字符串")
                return False
            
            return True
        except Exception as e:
            logger.error(f"数据格式校验失败: {e}")
            return False
    
    def _save_result_to_file(self, data: Union[VulnerabilityResult, List[Dict]], file_path: str, is_batch: bool = False) -> bool:
        """保存结果到文件，添加存储容错"""
        try:
            # 确保输出目录存在
            os.makedirs(os.path.dirname(file_path), exist_ok=True)
            
            # 准备要写入的数据
            if not is_batch and isinstance(data, VulnerabilityResult):
                json_data = data.__dict__
            else:
                json_data = data
            
            # 写入文件，添加异常处理
            # 先转换为JSON字符串
            json_str = json.dumps(json_data, ensure_ascii=False, indent=2)
            
            # 使用正则表达式将ingress字段的列表格式化为一行
            import re
            json_str = re.sub(r'"ingress":\s*\[\s*(\d+)\s*\]', r'"ingress": [\1]', json_str)
            
            with open(file_path, 'w', encoding='utf-8') as f:
                f.write(json_str)
            
            return True
        except PermissionError:
            logger.error(f"没有写入权限: {file_path}")
            return False
        except IsADirectoryError:
            logger.error(f"路径是目录，不是文件: {file_path}")
            return False
        except Exception as e:
            logger.error(f"保存文件失败 {file_path}: {e}")
            return False

class VulhubKnowledgeBase:
    """VULHUB知识库 - 支持CSV和JSON格式"""
    
    def __init__(self, kb_path: str):
        self.kb_path = kb_path
        self.kb_data = self._load_knowledge_base()
    
    def _load_knowledge_base(self) -> Dict[str, Any]:
        """加载知识库数据"""
        try:
            if os.path.exists(self.kb_path):
                if self.kb_path.endswith('.csv'):
                    return self._load_csv_as_dict()
                else:
                    with open(self.kb_path, 'r', encoding='utf-8') as f:
                        return json.load(f)
            else:
                logger.warning(f"知识库文件不存在: {self.kb_path}")
                return {}
        except Exception as e:
            logger.error(f"加载知识库失败: {e}")
            return {}
    
    def _load_csv_as_dict(self) -> Dict[str, Any]:
        """将CSV文件加载为字典格式"""
        result = {}
        try:
            with open(self.kb_path, 'r', encoding='utf-8-sig') as csvfile:
                reader = csv.DictReader(csvfile)
                for row in reader:
                    # 使用name字段作为key
                    cve_name = row.get('name', '')
                    if cve_name:
                        result[cve_name] = {
                            'name': row.get('name', ''),
                            'path': row.get('path', ''),
                            'description': f"CVE漏洞: {row.get('name', '')}",
                            'vuln_type': 'unknown'
                        }
            logger.info(f"成功加载CSV知识库，共 {len(result)} 条记录")
            return result
        except Exception as e:
            logger.error(f"加载CSV文件失败: {e}")
            return {}
    
    def search(self, query: str) -> Dict[str, Any]:
        """
        在知识库中搜索
        
        Args:
            query: 搜索查询
            
        Returns:
            搜索结果
        """
        # 简单的关键词匹配搜索
        results = {}
        
        # 首先尝试提取CVE编号
        cve_match = re.search(r'CVE-\d{4}-\d+', query)
        search_terms = []
        
        if cve_match:
            cve_id = cve_match.group(0)
            search_terms.append(cve_id)
        
        # 添加其他常见关键词
        query_lower = query.lower()
        if 'imagemagick' in query_lower:
            search_terms.append('imagemagick')
        if 'spring' in query_lower:
            search_terms.append('spring')
        if 'activemq' in query_lower:
            search_terms.append('activemq')
        if 'h2' in query_lower:
            search_terms.append('h2')
        if 'tomcat' in query_lower:
            search_terms.append('tomcat')
        if 'nginx' in query_lower:
            search_terms.append('nginx')
        
        # 如果没有提取到关键词，使用原始查询
        if not search_terms:
            search_terms = [query]
        
        for term in search_terms:
            for key, value in self.kb_data.items():
                # 在key中搜索
                if term.lower() in key.lower():
                    results[key] = value
                    continue
                    
                # 在value的各个字段中搜索
                value_str = str(value).lower()
                if term.lower() in value_str:
                    results[key] = value
        
        return results
    
    def get_name_path(self, query: str) -> Dict[str, str]:
        """
        获取NAME和PATH
        
        Args:
            query: 搜索查询
            
        Returns:
            包含name和path的字典
        """
        results = self.search(query)
        if results:
            # 返回第一个匹配结果
            first_result = list(results.values())[0]
            return {
                "name": first_result.get("name", ""),
                "path": first_result.get("path", "")
            }
        return {"name": "", "path": ""}
    
    def call_llm_api(self, cve_number: str, context: str = "") -> Dict[str, str]:
        """调用大模型API生成vuln_type和rag_summary"""
        # 这里需要配置你的LLM API
        if not self.llm_config["api_url"]:
            logger.warning("未配置LLM API，使用默认值")
            return {
                "vuln_type": "unknown",
                "rag_summary": f"未匹配到有效漏洞名称: {cve_number}"
            }
        
        try:
            # 构建提示词
            prompt = f"""
请为漏洞 {cve_number} 生成以下信息：

{self.template}

漏洞详细信息：{context}

请严格按照模板格式生成中文rag_summary，内容要准确、专业、详细。
同时生成漏洞类型（vuln_type），如：rce, sqli, xss, ssrf等。

输出格式：
vuln_type: <漏洞类型>
rag_summary: <按照模板生成的中文描述>
"""
            
            # 这里应该调用实际的LLM API
            # response = requests.post(
            #     self.llm_config["api_url"],
            #     headers={
            #         'Authorization': f'Bearer {self.llm_config["api_key"]}',
            #         'Content-Type': 'application/json'
            #     },
            #     json={
            #         "prompt": prompt,
            #         "max_tokens": 2000,
            #         "temperature": 0.7
            #     }
            # )
            
            # 临时返回默认值
            return {
                "vuln_type": "unknown",
                "rag_summary": f"未匹配到有效漏洞名称: {cve_number}"
            }
            
        except Exception as e:
            logger.error(f"LLM API调用失败: {e}")
            return {
                "vuln_type": "unknown", 
                "rag_summary": f"未匹配到有效漏洞名称: {cve_number}"
            }
    
    def search_in_knowledge_base(self, cve_number: str) -> Optional[str]:
        """在知识库中搜索CVE编号"""
        if cve_number in self.knowledge_base:
            return self.knowledge_base[cve_number]
        return None

class VulhubRepoClient:
    """VULHUB仓库客户端"""
    
    def __init__(self, repo_url: str):
        self.repo_url = repo_url
        self.base_url = "https://raw.githubusercontent.com/vulhub/vulhub/master"
    
    def get_docker_compose(self, path: str) -> Optional[Dict[str, Any]]:
        """
        获取docker-compose.yml内容
        
        Args:
            path: 漏洞路径
            
        Returns:
            docker-compose配置
        """
        try:
            compose_url = f"{self.base_url}/{path}/docker-compose.yml"
            response = requests.get(compose_url)
            if response.status_code == 200:
                # 解析docker-compose.yml
                content = response.text
                return self._parse_docker_compose(content)
            else:
                logger.warning(f"无法获取docker-compose.yml: {compose_url}")
                return None
        except Exception as e:
            logger.error(f"获取docker-compose失败: {e}")
            return None
    
    def _parse_docker_compose(self, content: str) -> Dict[str, Any]:
        """解析docker-compose内容"""
        # 简单的解析逻辑，提取image和ports
        result = {
            "image": "",
            "ports": []
        }
        
        # 提取image
        image_match = re.search(r'image:\s*(.+)', content)
        if image_match:
            result["image"] = image_match.group(1).strip()
        
        # 提取ports
        port_matches = re.findall(r'ports:\s*\n\s*-\s*["\']?([^"\'\n]+)["\']?', content)
        result["ports"] = port_matches
        
        return result
    
    def get_readme(self, path: str) -> Optional[str]:
        """
        获取README文件内容
        
        Args:
            path: 漏洞路径
            
        Returns:
            README内容
        """
        try:
            readme_urls = [
                f"{self.base_url}/{path}/README.md",
                f"{self.base_url}/{path}/README",
                f"{self.base_url}/{path}/readme.md"
            ]
            
            for readme_url in readme_urls:
                response = requests.get(readme_url)
                if response.status_code == 200:
                    return response.text
                    
            logger.warning(f"无法获取README文件: {path}")
            return None
        except Exception as e:
            logger.error(f"获取README失败: {e}")
            return None

class LLMClient:
    """大模型客户端"""
    
    def __init__(self, api_url: str, api_key: str):
        self.api_url = api_url
        self.api_key = api_key
    
    def generate_vuln_summary(self, context: str, name: str) -> str:
        """
        生成漏洞摘要
        
        Args:
            context: 上下文信息
            name: 漏洞名称
            
        Returns:
            生成的摘要
        """
        try:
            # 如果没有配置API，使用简单的模板生成
            if not self.api_url or not self.api_key:
                return self._template_summary(name, context)
            
            # 调用大模型API
            prompt = f"""
请为以下漏洞生成详细的中文描述摘要：

漏洞名称: {name}
相关信息: {context}

请包含：
1. 漏洞基本信息
2. 影响版本
3. 攻击方式
4. 危害程度
5. 环境信息

请用中文回答，格式清晰。
"""
            
            # 这里应该调用实际的LLM API
            # response = requests.post(self.api_url, headers={'Authorization': f'Bearer {self.api_key}'}, json={'prompt': prompt})
            # return response.json().get('content', '')
            
            # 临时使用模板生成
            return self._template_summary(name, context)
            
        except Exception as e:
            logger.error(f"LLM调用失败: {e}")
            return self._template_summary(name, context)
    
    def _template_summary(self, name: str, context: str) -> str:
        """模板生成摘要"""
        return f"漏洞 {name} 的详细描述：{context}"

class MCPClient:
    """MCP工具客户端"""
    
    def __init__(self, server_url: str):
        self.server_url = server_url
    
    def search_vulnerability(self, query: str) -> Dict[str, Any]:
        """
        使用MCP工具搜索漏洞信息
        
        Args:
            query: 搜索查询
            
        Returns:
            搜索结果
        """
        try:
            # 如果没有配置服务器URL，返回空结果
            if not self.server_url:
                return {}
            
            # 这里应该调用MCP工具
            # response = requests.post(self.server_url, json={'method': 'search_vulnerability', 'params': [query]})
            # return response.json()
            
            # 临时返回空结果
            return {}
            
        except Exception as e:
            logger.error(f"MCP工具调用失败: {e}")
            return {}

class VulnerabilityDataPipeline:
    """漏洞数据标注Pipeline主类"""
    
    def __init__(self, config: PipelineConfig):
        self.config = config
        self.document_extractor = DocumentExtractor()
        self.string_processor = StringArrayProcessor()
        self.knowledge_base = VulhubKnowledgeBase(config.vulhub_knowledge_base_path)
        self.repo_client = VulhubRepoClient(config.vulhub_repo_url)
        self.llm_client = LLMClient(config.llm_api_url, config.llm_api_key)
        self.mcp_client = MCPClient(config.mcp_server_url)
        
        # 创建输出目录
        os.makedirs(config.output_path, exist_ok=True)
    
    def process_input(self, input_data: Union[str, List[str]], input_type: InputType) -> str:
        """
        处理输入 - 第一阶段
        
        Args:
            input_data: 输入数据
            input_type: 输入类型
            
        Returns:
            处理后的字符串
        """
        logger.info("第一阶段：输入处理与知识库检索")
        
        if input_type == InputType.FILE:
            # 输入类型为文件
            content = self.document_extractor.extract_from_file(input_data)
            processed_content = self.string_processor.array_to_single_string([content])
        else:
            # 输入为文字
            processed_content = input_data if isinstance(input_data, str) else str(input_data)
        
        return processed_content
    
    def search_knowledge_base(self, content: str) -> KnowledgeBaseStatus:
        """
        搜索知识库 - 第一阶段
        
        Args:
            content: 内容
            
        Returns:
            知识库状态
        """
        kb_results = self.knowledge_base.search(content)
        return KnowledgeBaseStatus.EXISTS if kb_results else KnowledgeBaseStatus.NOT_EXISTS
    
    def handle_knowledge_base_flow(self, kb_status: KnowledgeBaseStatus, input_data: Union[str, List[str]], input_type: InputType) -> Dict[str, str]:
        """
        处理知识库流程 - 第二阶段
        
        Args:
            kb_status: 知识库状态
            input_data: 输入数据
            input_type: 输入类型
            
        Returns:
            包含name和path的字典
        """
        logger.info("第二阶段：知识库分支处理逻辑")
        
        if kb_status == KnowledgeBaseStatus.EXISTS:
            # 知识库存在
            name_path = self.knowledge_base.get_name_path(str(input_data))
        else:
            # 知识库不存在
            if input_type == InputType.FILE:
                name = self._extract_name_from_file(input_data)
            else:
                name = self._extract_name_from_text(input_data)
            
            path = self._generate_path_from_name(name)
            name_path = {"name": name, "path": path}
        
        return name_path
    
    def _extract_name_from_file(self, file_path: str) -> str:
        """从文件提取名称"""
        # 简单的文件名提取逻辑
        return os.path.splitext(os.path.basename(file_path))[0]
    
    def _extract_name_from_text(self, text: str) -> str:
        """从文本提取名称"""
        # 查找CVE编号
        cve_match = re.search(r'CVE-\d{4}-\d+', text)
        if cve_match:
            return cve_match.group(0)
        
        # 查找其他可能的名称模式
        name_match = re.search(r'漏洞\s*[:：]\s*([^\s，,。.]+)', text)
        if name_match:
            return name_match.group(1)
        
        return "未知漏洞"
    
    def _generate_path_from_name(self, name: str) -> str:
        """从名称生成路径"""
        # 简单的路径生成逻辑
        return name.lower().replace('cve-', '').replace('_', '/')
    
    def generate_vulnerability_data(self, name_path: Dict[str, str]) -> VulnerabilityData:
        """
        生成漏洞数据 - 第三阶段
        
        Args:
            name_path: 包含name和path的字典
            
        Returns:
            完整的漏洞数据
        """
        logger.info("第三阶段：VULHUB仓库检索与数据生成")
        
        name = name_path["name"]
        path = name_path["path"]
        
        # 检索VULHUB仓库
        docker_compose = self.repo_client.get_docker_compose(path)
        readme_content = self.repo_client.get_readme(path)
        
        # 提取字段
        image = docker_compose["image"] if docker_compose else ""
        ingress = docker_compose["ports"] if docker_compose else []
        
        # 生成漏洞类型
        vuln_type = self._determine_vuln_type(name, readme_content)
        
        # 使用LLM生成RAG摘要
        context = f"漏洞名称: {name}, 路径: {path}, 镜像: {image}, README: {readme_content}"
        rag_summary = self.llm_client.generate_vuln_summary(context, name)
        
        # 使用MCP工具增强数据
        mcp_results = self.mcp_client.search_vulnerability(name)
        
        return VulnerabilityData(
            rag_summary=rag_summary,
            name=name,
            path=path,
            image=image,
            contracts={
                "ingress": ingress,
                "vuln_type": vuln_type
            }
        )
    
    def _determine_vuln_type(self, name: str, readme_content: str) -> str:
        """确定漏洞类型"""
        # 简单的漏洞类型判断逻辑
        if readme_content:
            content_lower = readme_content.lower()
            if 'rce' in content_lower or 'remote code execution' in content_lower:
                return 'rce'
            elif 'sqli' in content_lower or 'sql injection' in content_lower:
                return 'sqli'
            elif 'xss' in content_lower or 'cross site scripting' in content_lower:
                return 'xss'
        
        return 'unknown'
    
    def process_cve(self, cve_number: str) -> VulnerabilityResult:
        """处理单个CVE编号"""
        logger.info(f"处理CVE编号: {cve_number}")
        
        # 在知识库中搜索
        vuln_path = self.search_in_knowledge_base(cve_number)
        
        if vuln_path:
            # 知识库中有对应漏洞
            logger.info(f"在知识库中找到 {cve_number}: {vuln_path}")
            
            # 读取docker-compose.yml文件
            docker_info = self.read_docker_compose(vuln_path)
            
            # 读取README文件
            readme_content = self.read_readme_file(vuln_path)
            
            # 调用大模型生成vuln_type和rag_summary
            context = f"漏洞路径: {vuln_path}, Docker镜像: {docker_info['image']}, 端口: {docker_info['ingress']}, README内容: {readme_content[:500]}"
            llm_result = self.call_llm_api(cve_number, context)
            
        else:
            # 知识库中没有对应漏洞，调用大模型搜索
            logger.info(f"在知识库中未找到 {cve_number}，调用大模型搜索")
            
            # 设置默认值
            vuln_path = "unknown"
            docker_info = {"image": "", "ingress": []}
            llm_result = self.call_llm_api(cve_number, "")
        
        return VulnerabilityResult(
            rag_summary=llm_result["rag_summary"],
            name=cve_number,
            path=vuln_path,
            image=docker_info["image"],
            contracts={
                "ingress": docker_info["ingress"],
                "vuln_type": llm_result["vuln_type"]
            }
        )
    
    def run(self, input_data: str = None, input_file: str = None) -> List[VulnerabilityResult]:
        """运行主流程"""
        logger.info("开始漏洞检索流程")
        
        results = []
        
        if input_data:
            # 处理文字输入
            cve_numbers = self.extract_cve_numbers(input_data)
            logger.info(f"从文字输入提取到 {len(cve_numbers)} 个CVE编号: {cve_numbers}")
        
        elif input_file:
            # 处理文件输入
            try:
                with open(input_file, 'r', encoding='utf-8') as f:
                    file_content = f.read()
                cve_numbers = self.extract_cve_numbers(file_content)
                logger.info(f"从文件 {input_file} 提取到 {len(cve_numbers)} 个CVE编号: {cve_numbers}")
            except Exception as e:
                logger.error(f"读取文件失败 {input_file}: {e}")
                return results
        
        else:
            logger.error("请提供输入数据或文件")
            return results
        
        # 处理每个CVE编号
        for cve_number in cve_numbers:
            try:
                result = self.process_cve(cve_number)
                results.append(result)
                
            except Exception as e:
                logger.error(f"处理CVE {cve_number} 失败: {e}")
                continue
        
        # 根据处理的漏洞数量决定输出方式
        if len(results) == 1:
            # 单个漏洞：只输出单个结果
            cve_number = results[0].name
            output_file = os.path.join(self.output_path, f"{cve_number}.json")
            with open(output_file, 'w', encoding='utf-8') as f:
                json.dump(results[0].__dict__, f, ensure_ascii=False, indent=2)
            logger.info(f"单个漏洞结果已保存到: {output_file}")
        elif len(results) >= 2:
            # 多个漏洞：只输出批量结果
            batch_output_file = os.path.join(self.output_path, f"批量结果_{len(results)}个漏洞.json")
            with open(batch_output_file, 'w', encoding='utf-8') as f:
                json.dump([result.__dict__ for result in results], f, ensure_ascii=False, indent=2)
            logger.info(f"批量结果已保存到: {batch_output_file}")
        
        logger.info(f"漏洞检索流程完成，共处理 {len(results)} 个CVE")
        return results
    
def main():
    """主函数 - 交互式用户界面"""
    print("=== 漏洞检索系统 ===")
    
    # 创建漏洞检索系统实例
    retriever = VulnerabilityRetriever()
    
    # 检查LLM API配置
    if not retriever.llm_config["api_url"] or "api_keys" in retriever.llm_config["api_url"]:
        print("\n警告: LLM API URL配置不正确，请检查config.json文件中的llm_config.api_url配置")
    else:
        print(f"\n使用配置的LLM API: {retriever.llm_config['model']}")
    
    while True:
        print("\n请选择输入方式:")
        print("1. 文字输入")
        print("2. 文件上传")
        print("0. 退出")
        
        choice = input("\n请输入选择 (0-2): ").strip()
        
        if choice == "0":
            print("\n感谢使用漏洞检索系统，再见！")
            break
            
        elif choice == "1":
            print("\n=== 文字输入模式 ===")
            text_input = input("请输入包含CVE编号的文本: ").strip()
            
            if not text_input:
                print("错误: 输入不能为空")
                continue
                
            results = retriever.run(input_data=text_input)
            print(f"\n处理完成，共处理了 {len(results)} 个CVE编号")
            if results:
                print("结果已保存至 output/ 目录")
        
        elif choice == "2":
            print("\n=== 文件上传模式 ===")
            file_path = input("请输入文件路径: ").strip()
            
            if not file_path:
                print("错误: 文件路径不能为空")
                continue
                
            if not os.path.exists(file_path):
                print(f"错误: 文件不存在: {file_path}")
                continue
                
            if not os.path.isfile(file_path):
                print(f"错误: 不是有效的文件: {file_path}")
                continue
                
            results = retriever.run(input_file=file_path)
            print(f"\n处理完成，共处理了 {len(results)} 个CVE编号")
            if results:
                print("结果已保存至 output/ 目录")
        
        else:
            print(f"错误: 无效的选择 '{choice}'，请重新输入")
    
    print("\n系统已退出")
    
if __name__ == "__main__":
    main()
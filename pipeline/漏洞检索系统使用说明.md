# 靶标数据自动化标注使用说明

## 1. 概述

`vulnerability_pipeline.py` 实现了一个完整的漏洞检索系统，能够根据用户提供的CVE编号，从知识库中检索漏洞信息，并调用大模型生成标准化的漏洞类型和摘要。系统支持文字输入和文件输入两种方式，输出结构化的JSON格式漏洞报告。

## 2. 核心功能

### 2.1 漏洞信息检索

- **CVE编号提取**：自动从用户输入的文字或文件中提取CVE编号
- **知识库查询**：在本地知识库(`cve_list.csv`)中搜索对应漏洞的路径信息
- **Docker信息解析**：读取漏洞环境的docker-compose.yml文件，提取镜像和端口信息
- **README内容提取**：读取漏洞的README文件，获取详细漏洞描述

### 2.2 大模型集成

- **LLM API调用**：支持调用DeepSeek等大模型API
- **标准化字段生成**：
  - `vuln_type`：严格按照配置的漏洞类型列表生成标准化漏洞类型
  - `rag_summary`：生成包含漏洞核心要素的结构化摘要

### 2.3 结果输出

- **单个漏洞报告**：为每个CVE生成独立的JSON结果文件
- **批量结果汇总**：生成包含所有处理结果的批量报告
- **结果持久化**：所有结果保存至 `output`目录

## 3. 系统架构

```
┌─────────────────────────────────────────────────────────┐
│                    漏洞检索系统                          │
├─────────────┬─────────────────┬─────────────────────────┤
│  输入处理层  │  核心处理层      │  输出处理层             │
├─────────────┼─────────────────┼─────────────────────────┤
│ - 文字输入   │ - 知识库查询     │ - 单个结果保存          │
│ - 文件输入   │ - Docker解析     │ - 批量结果汇总          │
│ - CVE提取    │ - README解析     │ - 日志记录              │
│              │ - LLM API调用    │                         │
│              │ - 结果生成       │                         │
└─────────────┴─────────────────┴─────────────────────────┘
```

## 4. 快速开始

### 4.1 环境准备

1. 安装依赖：

```bash
pip install requests pyyaml
```

2. 配置LLM API：
   编辑 `config.json`文件，设置正确的API URL和密钥：

```json
{
  "llm_config": {
    "api_url": "https://api.deepseek.com/v1/chat/completions",
    "model": "deepseek-chat",
    "temperature": 0.5,
    "api_key": "YOUR_API_KEY",
    "prompt_template": "请根据提供的漏洞信息，严格按照以下模板生成中文描述摘要：..."
  },
  "vuln_types": ["rce", "xss", "ssrf", ...]
}
```

### 4.2 基本使用

#### 方法一：直接运行脚本（交互式界面）

```bash
python vulnerability_pipeline.py
```

运行后系统会显示交互式菜单，您可以选择文字输入或文件上传模式：

```
=== 漏洞检索系统 ===
使用配置的LLM API: deepseek-chat

请选择输入方式:
1. 文字输入
2. 文件上传
0. 退出

请输入选择 (0-2): 
```

**文字输入模式**：直接输入包含CVE编号的文本，系统会自动提取并处理所有CVE编号

**文件上传模式**：输入文件路径，系统会读取文件内容并提取所有CVE编号

#### 方法二：在Python代码中使用

```python
from vulnerability_pipeline import VulnerabilityRetriever

# 创建漏洞检索系统实例
retriever = VulnerabilityRetriever()

# 示例1：文字输入
text_input = "CVE-2016-3714 CVE-2018-10054"
results1 = retriever.run(input_data=text_input)
print(f"处理了 {len(results1)} 个CVE编号")

# 示例2：文件输入
results2 = retriever.run(input_file="test_input.txt")
print(f"从文件处理了 {len(results2)} 个CVE编号")

# 示例3：单个CVE编号处理
single_result = retriever.process_cve("CVE-2021-25646")
print(f"处理结果：{single_result.name}")
```

## 5. 详细使用指南

### 5.1 输入方式

#### 文字输入

直接提供包含CVE编号的文本字符串，系统会自动提取所有CVE编号：

```python
results = retriever.run(input_data="CVE-2016-3714 CVE-2018-10054 CVE-2021-25646")
```

#### 文件输入

提供包含CVE编号的文本文件路径，系统会读取文件内容并提取所有CVE编号：

```python
results = retriever.run(input_file="test_input.txt")
```

文件内容示例：

```
CVE-2016-3714
CVE-2018-10054
CVE-2021-25646 Spring Cloud Gateway远程代码执行漏洞
```

### 5.2 配置文件说明

`config.json` 包含系统的核心配置：

```json
{
  "output_path": "output",                    # 结果输出目录
  "knowledge_base_path": "cve_list.csv",     # 知识库路径
  "vuln_types": ["rce", "xss", ...],        # 支持的漏洞类型列表
  "vuln_path_prefix": "..",                   # 漏洞路径前缀
  "llm_config": {                              # LLM API配置
    "api_url": "https://api.deepseek.com/v1/chat/completions",
    "model": "deepseek-chat",
    "temperature": 0.5,
    "api_key": "YOUR_API_KEY",
    "prompt_template": "请根据提供的漏洞信息..."
  }
}
```

### 5.3 知识库管理

系统使用 `cve_list.csv`作为本地知识库，格式如下：

```csv
CVE-2016-3714,imagemagick/CVE-2016-3714
CVE-2018-10054,spring/CVE-2018-10054
CVE-2021-25646,spring/CVE-2021-25646
```

### 5.4 输出结果格式

单个漏洞报告示例：

```json
{
  "rag_summary": "漏洞 CVE-2016-3714 是 ImageMagick 6.9.3-9之前版本中的命令注入漏洞...",
  "name": "CVE-2016-3714",
  "path": "imagemagick/CVE-2016-3714",
  "image": "vulhub/imagemagick:6.9.2-10-php",
  "contracts": {
    "ingress": [8080],
    "vuln_type": "rce"
  }
}
```

### 5.5 支持的漏洞类型

系统支持27种标准化漏洞类型：

- rce (远程代码执行)
- sqli (SQL注入)
- xss (跨站脚本攻击)
- lfi (本地文件包含)
- ssrf (服务端请求伪造)
- deserialization (反序列化漏洞)
- auth_bypass (认证绕过)
- privilege_escalation (权限提升)
- directory_traversal (目录遍历)
- command_injection (命令注入)
- code_execution (代码执行)
- remote_code_execution (远程代码执行)
- cross_site_scripting (跨站脚本攻击)
- sql_injection (SQL注入)
- local_file_inclusion (本地文件包含)
- server_side_request_forgery (服务端请求伪造)
- authentication_bypass (认证绕过)
- file_upload (文件上传漏洞)
- buffer_overflow (缓冲区溢出)
- information_disclosure (信息泄露)
- csrf (跨站请求伪造)
- broken_access_control (访问控制失效)
- cryptographic_failure (加密失败)
- insecure_design (不安全设计)
- security_misconfiguration (安全配置错误)
- vulnerable_and_outdated_components (脆弱和过时的组件)
- identification_and_authentication_failures (身份识别和认证失败)

## 6. 常见问题与解决方案

### 6.1 LLM API调用失败

**问题**：`api_url`配置错误或API密钥无效
**解决方案**：检查 `config.json`中的 `llm_config.api_url`配置，确保URL正确且不包含 `api_keys`等错误信息

### 6.2 知识库中未找到漏洞

**问题**：输入的CVE编号在 `cve_list.csv`中不存在
**解决方案**：检查CVE编号格式是否正确，或在知识库中添加该漏洞的映射关系

### 6.3 结果中缺少vuln_type或rag_summary

**问题**：LLM API调用失败或提示词模板错误
**解决方案**：

1. 检查网络连接和LLM API配置
2. 检查 `config.json`中的 `llm_config.prompt_template`格式是否正确
3. 确保提示词模板中包含 `{name}`和 `{context}`占位符

### 6.4 依赖缺失

**问题**：运行时提示缺少pyyaml或requests模块
**解决方案**：执行 `pip install pyyaml requests`安装所需依赖

## 7. 代码结构

### 7.1 核心类与方法

```python
class VulnerabilityRetriever:
    def __init__(self):  # 初始化配置、知识库和LLM参数
    def extract_cve_numbers(self, text: str) -> List[str]:  # 提取CVE编号
    def search_in_knowledge_base(self, cve_number: str) -> Optional[str]:  # 知识库查询
    def call_llm_api(self, cve_number: str, context: str = "") -> Dict[str, str]:  # LLM API调用
    def process_cve(self, cve_number: str) -> VulnerabilityResult:  # 处理单个CVE
    def run(self, input_data: str = None, input_file: str = None) -> List[VulnerabilityResult]:  # 主流程入口
```

### 7.2 关键流程

1. **初始化**：加载配置文件、知识库和LLM参数
2. **输入处理**：提取CVE编号
3. **漏洞检索**：查询知识库，获取漏洞路径
4. **信息提取**：解析Docker和README文件
5. **LLM调用**：生成标准化字段
6. **结果输出**：保存JSON结果文件

## 8. 扩展与定制

### 8.1 自定义漏洞类型

在 `config.json`的 `vuln_types`列表中添加新的漏洞类型即可扩展支持的类型。

### 8.2 优化LLM提示词

修改 `config.json`中的 `llm_config.prompt_template`可以优化大模型生成的结果质量。

### 8.3 扩展知识库

可以通过编辑 `cve_list.csv`文件来扩展本地知识库，添加新的CVE编号与漏洞路径的映射关系。

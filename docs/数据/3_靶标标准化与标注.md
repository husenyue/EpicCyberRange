
# 候选靶标标准化定义与高效标注方法

好的，我们暂停编排协议的设计，来深入思考靶标镜像的标准化定义和高效标注问题。这其实是整个系统的**数据基础**，非常关键。

---

## 1. 候选靶标的标准化定义（精炼版）

基于之前设计的 v3 规范，我进一步精炼为**最小必要集**，确保既能支持约束求解，又便于标注：

### 1.1 核心 Schema（v4 - 标注友好版）

```yaml
# target_image_spec_v4.yaml
image_id: "vulhub/struts2/s2-045"  # 唯一标识，建议用路径风格

# ===== 基础信息（可自动提取）=====
metadata:
  name: "Apache Struts2 S2-045 RCE"
  source: "vulhub"
  source_path: "struts2/s2-045"
  cve_ids: ["CVE-2017-5638"]
  cwe_ids: ["CWE-94"]  # Code Injection
  description: "基于 Content-Type 头的 OGNL 表达式注入导致远程代码执行"

# ===== 接口定义（半自动）=====
interfaces:
  exposes:  # 对外暴露什么
    - port: 8080
      protocol: HTTP
      service: "Apache Struts2 2.3.31"
  
  requires:  # 依赖什么（可选）
    - service_class: "none"  # 此镜像无外部依赖

# ===== 漏洞语义（需标注）=====
vulnerability:
  entry_point: "HTTP:8080"
  weakness_class: "remote_code_execution"
  
  # 前置条件：攻击者需要什么能力才能利用
  preconditions:
    - capability: "network_access"
      target: "self:8080"
  
  # 后置条件：成功利用后获得什么
  postconditions:
    - capability: "shell_access"
      level: "container_user"  # 非 root
    - capability: "network_pivot"
      description: "可从该容器发起内网请求"

# ===== 验证方法（需标注）=====
verification:
  # 健康检查：确认服务正常启动
  health_check:
    method: "http_get"
    target: "http://${HOST}:8080"
    expect: { status_code: 200 }
    timeout: 30s
  
  # 漏洞验证：确认漏洞可利用
  exploit_check:
    method: "nuclei"  # 或 "script" / "manual"
    template: "CVE-2017-5638"
    # 或者自定义脚本
    # method: "script"
    # script: |
    #   curl -H "Content-Type: %{...}" http://${HOST}:8080/
    expect: { result: "vulnerable" }
```

### 1.2 字段分类（按标注难度）

| 类别 | 字段 | 标注方式 | 说明 |
| --- | --- | --- | --- |
| **自动提取** | `metadata.*` | 解析 README / docker-compose | CVE、名称、描述 |
| **半自动** | `interfaces.exposes` | 解析 docker-compose + 验证 | 端口、协议 |
| **需推断** | `interfaces.requires` | LLM 辅助分析 | 依赖关系 |
| **需标注** | `vulnerability.*` | 人机协作 | 核心语义 |
| **需标注** | `verification.*` | 复用已有工具 | 验证方法 |

---

## 2. 从 Vulhub 高效构建候选池

让我先看一下 Vulhub 的结构，以便设计自动化流程：

让我进一步查看 Vulhub 的具体目录结构和单个漏洞环境的 README 格式：

让我获取 Vulhub 的 environments.toml 和一个具体的 README 来理解数据结构：

非常好！现在我对 Vulhub 的数据结构有了清晰的认识。让我搜索一下是否有现成的漏洞数据库或工具可以帮助自动化标注：

这些研究给了我很好的启发。现在我来综合设计一个高效的人机协作标注方案。

---

# 候选靶标标准化定义与高效标注方案

## 1. Vulhub 现有数据结构分析

基于对 Vulhub 的调研，其现有数据结构如下：

```plaintext
vulhub/
├── environments.toml          # 中央注册表（元数据索引）
└── {app}/{CVE-xxxx}/
    ├── docker-compose.yml     # 环境定义
    ├── README.md              # 英文漏洞说明
    ├── README.zh-cn.md        # 中文漏洞说明
    └── [poc脚本等]            # 可选的 PoC 代码
```

### 现有 `environments.toml` 字段

```plaintext
[[environment]]
name = "Apache Struts2 S2-045 RCE"
cve = ["CVE-2017-5638"]
app = "Apache Struts2"
path = "struts2/s2-045"
tags = ["RCE", "Expression Injection", "Framework"]
```

**优点：** 结构清晰，标签丰富\
**缺点：** 缺少约束求解所需的语义信息（端口、依赖、前后置条件）

---

## 2. 候选靶标标准化定义（面向约束求解）

### 2.1 设计原则

| 原则 | 说明 |
| --- | --- |
| **最小必要** | 只定义约束求解必须的字段 |
| **可自动化** | 尽可能从现有数据自动提取 |
| **渐进增强** | 核心字段必填，高级字段可选 |
| **兼容现有** | 与 Vulhub 结构无缝对接 |

### 2.2 标准化 Schema（v4）

```yaml
# target_spec.yaml - 靶标规范定义

# ============ 层级 1：自动提取 ============
image_id: "vulhub/struts2/s2-045"
source:
  repo: "vulhub"
  path: "struts2/s2-045"
  
metadata:
  name: "Apache Struts2 S2-045 RCE"
  cve_ids: ["CVE-2017-5638"]
  cwe_ids: ["CWE-94"]                    # 从 NVD 补充
  cvss_score: 10.0                        # 从 NVD 补充
  affected_versions: "2.3.5 - 2.3.31, 2.5 - 2.5.10"
  
tags:
  vuln_type: ["RCE", "Expression Injection"]
  app_type: ["Framework", "Webserver"]

# ============ 层级 2：半自动提取 ============
interfaces:
  exposes:
    - port: 8080
      protocol: HTTP
      service_class: "web_application"    # 标准化分类
      service_name: "Apache Struts2 2.3.30"
      
  requires: []  # 无外部依赖

# ============ 层级 3：需人工确认 ============
vulnerability:
  weakness_class: "remote_code_execution"  # 标准化分类
  
  preconditions:
    - type: "network_access"
      target: "HTTP:8080"
      
  postconditions:
    - type: "code_execution"
      level: "container_user"
    - type: "network_pivot"
      
  attack_vector:
    entry_point: "HTTP:8080"
    technique: "OGNL expression injection via Content-Type header"

# ============ 层级 4：验证配置 ============
verification:
  health_check:
    method: "http"
    endpoint: "http://${HOST}:8080"
    expect_status: 200
    timeout: 30
    
  exploit_check:
    method: "nuclei"
    template_id: "CVE-2017-5638"
    # 备选
    # method: "script"
    # script: "poc/exploit.py"
```

### 2.3 标准化分类枚举

```yaml
# taxonomies.yaml

service_class:
  - web_application
  - database
  - message_queue
  - cache
  - file_server
  - mail_server
  - dns
  - ssh
  - container_runtime
  - ci_cd
  - monitoring

weakness_class:
  - remote_code_execution
  - sql_injection
  - command_injection
  - path_traversal
  - authentication_bypass
  - privilege_escalation
  - information_disclosure
  - ssrf
  - xxe
  - deserialization
  - file_upload

capability:
  - network_access          # 可访问网络端口
  - code_execution          # 可执行任意代码
  - file_read               # 可读取文件
  - file_write              # 可写入文件
  - credential_access       # 可获取凭据
  - network_pivot           # 可作为跳板访问其他网络
  - container_escape        # 可逃逸容器
  - privilege_escalation    # 可提权
```

---

## 3. 高效人机协作标注方案

### 3.1 四层自动化架构

```plaintext
┌─────────────────────────────────────────────────────────────────────┐
│                    Layer 1: 全自动提取                               │
│  ┌──────────────┐  ┌──────────────┐  ┌──────────────┐              │
│  │ Vulhub TOML  │  │   NVD API    │  │ Nuclei Tmpl  │              │
│  │  Parser      │  │  Enricher    │  │  Matcher     │              │
│  └──────┬───────┘  └──────┬───────┘  └──────┬───────┘              │
│         │                 │                 │                       │
│         └────────────┬────┴────────────────┘                       │
│                      ▼                                              │
│              ┌──────────────┐                                       │
│              │  Base Spec   │  name, cve, tags, cvss...            │
│              └──────┬───────┘                                       │
└─────────────────────┼───────────────────────────────────────────────┘
                      │
┌─────────────────────┼───────────────────────────────────────────────┐
│                     ▼       Layer 2: 静态分析                        │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │              docker-compose.yml Parser                        │  │
│  │  - 提取 ports: "8080:8080" → interfaces.exposes               │  │
│  │  - 提取 depends_on → interfaces.requires                      │  │
│  │  - 提取 environment → 配置参数                                │  │
│  └──────────────────────────────────────────────────────────────┘  │
└─────────────────────┬───────────────────────────────────────────────┘
                      │
┌─────────────────────┼───────────────────────────────────────────────┐
│                     ▼       Layer 3: LLM 辅助推断                    │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                    LLM Analysis Agent                         │  │
│  │  Input:                                                       │  │
│  │    - CVE description (from NVD)                              │  │
│  │    - README.md content                                        │  │
│  │    - CWE definition                                          │  │
│  │  Output:                                                      │  │
│  │    - weakness_class mapping                                   │  │
│  │    - preconditions / postconditions                          │  │
│  │    - attack_vector description                               │  │
│  │    - confidence_score                                        │  │
│  └──────────────────────────────────────────────────────────────┘  │
└─────────────────────┬───────────────────────────────────────────────┘
                      │
┌─────────────────────┼───────────────────────────────────────────────┐
│                     ▼       Layer 4: 人工审核 & 修正                 │
│  ┌──────────────────────────────────────────────────────────────┐  │
│  │                 Human Review Interface                        │  │
│  │  - 显示 LLM 推断结果 + 置信度                                 │  │
│  │  - 高亮低置信度字段                                           │  │
│  │  - 一键确认 / 修改                                            │  │
│  │  - 反馈用于改进 LLM                                          │  │
│  └──────────────────────────────────────────────────────────────┘  │
└─────────────────────────────────────────────────────────────────────┘
```

### 3.2 各层详细实现

#### Layer 1: 全自动提取

```python
class AutoExtractor:
    """从已有数据源自动提取元数据"""
    
    def extract_from_vulhub(self, env_path: str) -> dict:
        """解析 environments.toml"""
        return {
            "name": env["name"],
            "cve_ids": env["cve"],
            "app": env["app"],
            "path": env["path"],
            "tags": env["tags"]
        }
    
    def enrich_from_nvd(self, cve_id: str) -> dict:
        """从 NVD API 补充信息"""
        nvd_data = self.nvd_client.get_cve(cve_id)
        return {
            "cwe_ids": nvd_data.weaknesses,
            "cvss_score": nvd_data.cvss_v3_score,
            "cvss_vector": nvd_data.cvss_v3_vector,
            "description": nvd_data.description,
            "affected_versions": nvd_data.affected_configurations
        }
    
    def match_nuclei_template(self, cve_id: str) -> Optional[str]:
        """匹配 Nuclei 模板用于验证"""
        # 搜索 nuclei-templates 仓库
        template_path = f"cves/{cve_id.split('-')[1]}/{cve_id}.yaml"
        if self.nuclei_repo.exists(template_path):
            return template_path
        return None
```

#### Layer 2: Docker Compose 静态分析

```python
class DockerComposeAnalyzer:
    """解析 docker-compose.yml 提取接口信息"""
    
    def analyze(self, compose_path: str) -> dict:
        with open(compose_path) as f:
            compose = yaml.safe_load(f)
        
        result = {"exposes": [], "requires": []}
        
        for service_name, service in compose.get("services", {}).items():
            # 提取暴露端口
            for port_mapping in service.get("ports", []):
                host_port, container_port = self._parse_port(port_mapping)
                result["exposes"].append({
                    "service": service_name,
                    "port": int(container_port),
                    "protocol": self._infer_protocol(container_port)
                })
            
            # 提取依赖关系
            for dep in service.get("depends_on", []):
                result["requires"].append({
                    "service": dep,
                    "type": "startup_dependency"
                })
        
        return result
    
    def _infer_protocol(self, port: int) -> str:
        """根据端口推断协议"""
        port_map = {
            80: "HTTP", 443: "HTTPS", 8080: "HTTP",
            3306: "MySQL", 5432: "PostgreSQL", 6379: "Redis",
            27017: "MongoDB", 22: "SSH", 21: "FTP"
        }
        return port_map.get(port, "TCP")
```

#### Layer 3: LLM 辅助推断（核心创新）

```python
class LLMAnnotationAgent:
    """LLM 辅助推断漏洞语义"""
    
    SYSTEM_PROMPT = """你是一个安全专家，负责分析漏洞信息并提取结构化语义。
    
你需要根据提供的 CVE 描述、README 内容和 CWE 定义，推断以下信息：
1. weakness_class: 从标准分类中选择最匹配的漏洞类型
2. preconditions: 利用该漏洞需要什么前置条件
3. postconditions: 成功利用后攻击者获得什么能力
4. attack_vector: 攻击入口和技术描述

对于每个推断，请给出 confidence (0.0-1.0) 表示你的确定程度。"""

    def analyze(self, context: AnnotationContext) -> AnnotationResult:
        prompt = self._build_prompt(context)
        response = self.llm.invoke(prompt)
        return self._parse_response(response)
    
    def _build_prompt(self, ctx: AnnotationContext) -> str:
        return f"""
## 输入信息

### CVE 信息
- CVE ID: {ctx.cve_id}
- 描述: {ctx.nvd_description}
- CVSS: {ctx.cvss_score}

### CWE 信息
- CWE ID: {ctx.cwe_ids}
- CWE 描述: {ctx.cwe_description}

### README 内容
{ctx.readme_content}

### 已知信息
- 暴露端口: {ctx.exposed_ports}
- 应用类型: {ctx.app_type}
- 现有标签: {ctx.tags}

## 标准分类（必须从中选择）

### weakness_class 选项
{WEAKNESS_CLASS_ENUM}

### capability 选项
{CAPABILITY_ENUM}

## 请输出 JSON 格式

```json
{{
  "weakness_class": {{
    "value": "选择的分类",
    "confidence": 0.95,
    "reasoning": "推理过程"
  }},
  "preconditions": [
    {{
      "type": "capability 类型",
      "target": "目标描述",
      "confidence": 0.9
    }}
  ],
  "postconditions": [
    {{
      "type": "capability 类型", 
      "level": "container_user | container_root | host",
      "confidence": 0.85
    }}
  ],
  "attack_vector": {{
    "entry_point": "协议:端口",
    "technique": "攻击技术描述",
    "confidence": 0.8
  }}
}}
```

"""

```plaintext

#### Layer 4: 人工审核界面

```typescript
// AnnotationReviewUI.tsx - 人工审核界面

interface AnnotationReview {
  imageId: string;
  autoExtracted: BaseSpec;      // Layer 1 结果
  staticAnalysis: InterfaceSpec; // Layer 2 结果
  llmInference: LLMResult;       // Layer 3 结果（含置信度）
}

function AnnotationReviewPanel({ review }: { review: AnnotationReview }) {
  return (
    <div classname="review-panel">
      {/* 元数据（自动提取，只读展示） */}
      <section title="基础信息" status="auto">
        <field label="CVE" value="{review.autoExtracted.cve_ids}">
        <field label="CVSS" value="{review.autoExtracted.cvss_score}">
      </field></field></section>
      
      {/* 接口信息（半自动，可修改） */}
      <section title="接口定义" status="review">
        <editablelist items="{review.staticAnalysis.exposes}" confidence="high">
      </editablelist></section>
      
      {/* 漏洞语义（LLM 推断，重点审核） */}
      <section title="漏洞语义" status="attention">
        <confidencefield label="漏洞类型" value="{review.llmInference.weakness_class}" confidence="{review.llmInference.weakness_class.confidence}" options="{WEAKNESS_CLASS_OPTIONS}" onconfirm="{handleConfirm}" oncorrect="{handleCorrection}">
        
        <confidencefield label="前置条件" value="{review.llmInference.preconditions}" confidence="{avgConfidence(review.llmInference.preconditions)}" 低于="" 0.8="" 置信度高亮显示="" highlight="{avgConfidence(...)" <="" 0.8}="">
      </confidencefield></confidencefield></section>
      
      {/* 操作按钮 */}
      <actionbar>
        <button onclick="{approveAll}">全部确认</button>
        <button onclick="{saveAndNext}">保存并继续</button>
        <button onclick="{flagForExpert}">标记需专家复核</button>
      </actionbar>
    </div>
  );
}
```

### 3.3 完整标注流水线

```python
class AnnotationPipeline:
    """完整的人机协作标注流水线"""
    
    def __init__(self):
        self.auto_extractor = AutoExtractor()
        self.compose_analyzer = DockerComposeAnalyzer()
        self.llm_agent = LLMAnnotationAgent()
        self.nuclei_matcher = NucleiTemplateMatcher()
    
    async def annotate_vulhub_environment(self, env_path: str) -> TargetSpec:
        """标注单个 Vulhub 环境"""
        
        # === Layer 1: 自动提取 ===
        base_info = self.auto_extractor.extract_from_vulhub(env_path)
        
        # 从 NVD 补充
        for cve_id in base_info["cve_ids"]:
            nvd_info = await self.auto_extractor.enrich_from_nvd(cve_id)
            base_info.update(nvd_info)
        
        # === Layer 2: 静态分析 ===
        compose_path = os.path.join(env_path, "docker-compose.yml")
        interfaces = self.compose_analyzer.analyze(compose_path)
        
        # === Layer 3: LLM 推断 ===
        readme_path = os.path.join(env_path, "README.md")
        readme_content = open(readme_path).read()
        
        context = AnnotationContext(
            cve_id=base_info["cve_ids"][0],
            nvd_description=base_info["description"],
            cwe_ids=base_info["cwe_ids"],
            readme_content=readme_content,
            exposed_ports=interfaces["exposes"],
            tags=base_info["tags"]
        )
        
        llm_result = await self.llm_agent.analyze(context)
        
        # === Layer 4: 匹配验证模板 ===
        nuclei_template = self.nuclei_matcher.find_template(
            cve_id=base_info["cve_ids"][0]
        )
        
        # === 组装结果 ===
        spec = TargetSpec(
            image_id=f"vulhub/{base_info['path']}",
            metadata=base_info,
            interfaces=interfaces,
            vulnerability=llm_result.to_vulnerability_spec(),
            verification={
                "nuclei_template": nuclei_template,
                "confidence_scores": llm_result.confidence_scores
            }
        )
        
        # 根据置信度决定是否需要人工审核
        if llm_result.min_confidence < 0.8:
            spec.status = "needs_review"
        else:
            spec.status = "auto_approved"
        
        return spec
    
    async def batch_annotate(self, vulhub_path: str) -> List[TargetSpec]:
        """批量标注整个 Vulhub 仓库"""
        
        environments = self._load_environments_toml(vulhub_path)
        results = []
        
        for env in tqdm(environments, desc="Annotating"):
            try:
                spec = await self.annotate_vulhub_environment(
                    os.path.join(vulhub_path, env["path"])
                )
                results.append(spec)
            except Exception as e:
                logger.error(f"Failed to annotate {env['path']}: {e}")
                results.append(TargetSpec(
                    image_id=f"vulhub/{env['path']}",
                    status="error",
                    error=str(e)
                ))
        
        # 统计
        auto_approved = sum(1 for r in results if r.status == "auto_approved")
        needs_review = sum(1 for r in results if r.status == "needs_review")
        errors = sum(1 for r in results if r.status == "error")
        
        logger.info(f"标注完成: {auto_approved} 自动通过, {needs_review} 需审核, {errors} 错误")
        
        return results
```

---

## 4. 利用 Nuclei 模板增强验证

Nuclei 拥有超过 **2456+ CVE 模板**，可以直接复用作为验证方法： [Introduction to Nuclei](https://www.vaadata.com/blog/introduction-to-nuclei-an-open-source-vulnerability-scanner/) [GitHub - projectdiscovery/nuclei](https://github.com/projectdiscovery/nuclei)

```python
class NucleiIntegration:
    """与 Nuclei 模板集成"""
    
    NUCLEI_TEMPLATES_REPO = "https://github.com/projectdiscovery/nuclei-templates"
    
    def find_template_for_cve(self, cve_id: str) -> Optional[NucleiTemplate]:
        """查找 CVE 对应的 Nuclei 模板"""
        year = cve_id.split("-")[1]
        template_path = f"http/cves/{year}/{cve_id}.yaml"
        
        if self.template_exists(template_path):
            return self.parse_template(template_path)
        return None
    
    def extract_verification_info(self, template: NucleiTemplate) -> dict:
        """从 Nuclei 模板提取验证信息"""
        return {
            "method": "nuclei",
            "template_id": template.id,
            "request": template.requests[0] if template.requests else None,
            "matchers": template.matchers,
            "severity": template.info.severity
        }
    
    def generate_exploit_check(self, template: NucleiTemplate) -> dict:
        """从模板生成 exploit_check 配置"""
        return {
            "method": "nuclei",
            "template": template.path,
            "expect": {
                "status": "vulnerable",
                "matchers": [m.name for m in template.matchers]
            }
        }
```

---

## 5. 预期效果与成本估算

### 5.1 自动化程度预估

| 字段类别 | 自动化率 | 人工工作量 |
| --- | --- | --- |
| 基础元数据 (name, cve, tags) | **100%** | 0 |
| 接口定义 (ports, protocols) | **95%** | 复核异常情况 |
| 漏洞语义 (preconditions, postconditions) | **70-80%** | 审核低置信度项 |
| 验证配置 (health_check, exploit_check) | **60%** | 无 Nuclei 模板时需自定义 |

### 5.2 标注成本对比

| 方案 | 每个靶标耗时 | 200个靶标总耗时 |
| --- | --- | --- |
| **纯人工** | 30-60 分钟 | 100-200 小时 |
| **人机协作** | 2-5 分钟（审核） | 7-17 小时 |
| **加速比** | **10-15x** | - |

### 5.3 实施建议

```plaintext
Phase 1: 基础设施搭建（1周）
├── 实现 Vulhub parser
├── 集成 NVD API
└── 搭建 Nuclei 模板索引

Phase 2: LLM 推断引擎（2周）
├── 设计 prompt 模板
├── 实现推断 pipeline
└── 置信度校准

Phase 3: 审核界面（1周）
├── Web UI 开发
├── 批量审核功能
└── 反馈收集

Phase 4: 初始标注（1周）
├── 标注 Vulhub 全部 200+ 环境
├── 收集修正数据
└── 优化 LLM prompt
```

---

## 6. 总结

| 维度 | 方案 |
| --- | --- |
| **标准化定义** | 四层渐进式 schema：自动提取 → 静态分析 → LLM 推断 → 人工确认 |
| **数据来源** | Vulhub (结构) + NVD (元数据) + Nuclei (验证模板) |
| **高效标注** | LLM 辅助推断 + 置信度驱动审核 + 批量处理 |
| **预期效率** | 10-15x 提速，从 200 小时 → 15 小时左右 |

这个方案利用了：

1. **现有生态**：Vulhub 结构 + NVD 数据 + Nuclei 模板

2. **LLM 推断**：从 CVE 描述和 README 自动推断语义

3. **人机协作**：只审核低置信度项，大幅减少人工

你想深入哪个部分？比如：

- LLM prompt 的详细设计

- 人工审核界面的交互设计

- 与现有 Topology Planner 的集成
